#!/bin/bash

# For all the directory and file names touched by this script,
# space in the name is not supported.
# Do not use space in directory and file names in ${HOME}/work and under it.


set -o errexit
set -o nounset
set -o pipefail

USAGE=$(cat <<'EOF'
Usage:

   run-docker [options] <image-name>[:tag] [<cmd> [cmd-args]]

where

`image-name` is like 'zppz/py3', etc.
If image tag is not specified, the most up-to-date tag is inferred and used.

`cmd` is the command to be run within the container, followed by arguments to the command.
(Default: /bin/bash)
EOF
)

if [[ $# < 1 ]]; then
    >&2 echo "${USAGE}"
    exit 1
fi


imagename=""
name=""  # container's name
command=/bin/bash  # the command to be run within the container
args=""  # args to `command`
opts=""  # args to `docker run`
nb_port=8888
gpu_devices=all

# You can limit to use specific GPUs, e.g.
# -e NVIDIA_VISIBLE_DEVICES=none
# -e NVIDIA_VISIBLE_DEVICES=0,1,3
# -e NVIDIA_VISIBLE_DEVICES=all

# To restrict memory usage, do something like
# --memory=8g
# Default is unlimited.
#
# See https://georgeoffley.com/blog/shared-memory-in-docker.html


# Parse arguments.
# Before the argument for image name,
# some arguments are consumed by this script;
# the rest are stored to be passed on to the command `docker run`.
# After the argument for image name,
# the first is the command to be executed in the container,
# others are arguments to the command.
while [[ $# > 0 ]]; do
    if [[ "${imagename}" == "" ]]; then
        if [[ "$1" == -v ]]; then
            # volume mapping, e.g.
            #   -v /tmp/data:/home/docker-user/data
            shift
            opts="${opts} -v $1"
        elif [[ "$1" == -p ]]; then
            # Port forwarding, e.g.
            #   -p 8080:8080
            shift
            opts="${opts} -p $1"
        elif [[ "$1" == -e ]]; then
            # Set env var, e.g.
            #   -e MYNAME=abc
            shift
            if [[ "$1" == NVIDIA_VISIBLE_DEVICES=* ]]; then
                zz="$1"
                gpu_devices="${zz#*=}"
            else
                opts="${opts} -e $1"
            fi
        elif [[ "$1" == --nb_port ]]; then
            # Port number for Jupyter Notebook.
            # Use this to avoid "port is being used" error.
            shift
            nb_port="$1"
        elif [[ "$1" == --nb_port=* ]]; then
            nb_port="$1"
            nb_port="${nb_port#*=}"

        elif [[ "$1" == -* ]]; then
            # Every other argument is captured and passed on to `docker run`.
            # For example, if there is an option called `--volume` which sets
            # something called 'volume', you may specify it like this
            #
            #   --volume=30
            #
            # You can not do
            #
            #   --volume 30
            #
            # because `run-docker` does not explicitly capture this option,
            # hence it does not know this option has two parts.
            # The same idea applies to other options.
            opts="${opts} $1"
        else
            imagename="$1"
        fi
        shift
    else
        # After `imagename`.
        command="$1"
        shift
        if [[ $# > 0 ]]; then
            args="$@"
        fi
        break
    fi
done

if [[ "${imagename}" == "" ]]; then
    >&2 echo "${USAGE}"
    exit 1
fi

HOSTWORKDIR="${HOME-/tmp}/work"
DOCKERHOMEDIR="/home/docker-user"
TINY=${TINY:-zppz/tiny:22.12.11}


function find-image {
    cmd=$(docker run --rm "${TINY}" cat /tools/find-image) || exit 1
    bash -c "${cmd}" -- $1
}


if [[ "${imagename}" != *:* && "${imagename}" != */* ]]; then
    # The image spec is a single word
    if [ -d "${HOSTWORKDIR}/src/${imagename}" ]; then
        # It is a source repo.
        imagename=${imagename}:dev
    elif [[ ${imagename} == data ]]; then
        imagename=zppz/py3
    fi
    # If neither the above 2, it's not a source repo.
    # Assume it's a shorthand for a frozen image.
fi

if [[ "${imagename}" == *:dev ]]; then
    # 'dev' is a special tag used by local dev images.
    IMAGENAME=${imagename}
    imagename=${IMAGENAME%:*}
    imageversion=dev
    reponame=${imagename}
    PROJ=${reponame}

    HOSTSRCDIR="${HOSTWORKDIR}/src/${reponame}"
    if [ ! -d "${HOSTSRCDIR}" ]; then
        >&2 echo Cannot find source directory \"${HOSTSRCDIR}\"
        exit 1
    fi

    opts="${opts} -v ${HOSTSRCDIR}:${DOCKERHOMEDIR}/${reponame} --workdir=${DOCKERHOMEDIR}/${reponame}"
    opts="${opts} -e PYTHONPATH=${DOCKERHOMEDIR}/${reponame}/src"
elif [[ ${imagename} == *:main || ${imagename} == *:release || ${imagename} == *:snapshot ]]; then
    # The image is built locally in branch 'main' or 'release' or 'snapshot' for testing
    IMAGENAME=${imagename}
    imagename=${IMAGENAME%:*}
    imageversion=${IMAGENAME#*:}
    reponame=${imagename}
    PROJ=
else
    if (( $(echo "${imagename}" | tr -cd '/' | wc -c) < 2 )); then
        # `$imagename` does not contain more than one '/', hence is not
        # a complete name
        IMAGENAME=$(find-image "${imagename}")
        if [ -z ${IMAGENAME} ]; then
            >&2 echo Could not find image ${imagename}
            exit 1
        fi
    else
        IMAGENAME="${imagename}"
    fi
    # `$IMAGENAME` contains the full name including url, namespace, etc.

    imageversion=${IMAGENAME##*:}
    imagename=${IMAGENAME%:*}
    imagename=${imagename##*/}
    # Now `$imagename` contains neither namespace nor tag.
    reponame="${imagename}"
    PROJ=
fi

if [[ "${args}" == '' && " /bin/bash /bin/sh bash sh python ptpython ptipython ipython " == *" ${command} "* ]]; then
    opts="${opts} -it"
fi

if [[ " ${opts} " != *" --name="* ]]; then
    # User did not specify a name for the container.
    name="$(whoami)-$(TZ=America/Los_Angeles date +%Y%m%d-%H%M%S)-pacific"
    opts="${opts} --name=${name}"
fi

if [[ " ${opts} " != *" --shm-size="* ]]; then
    # User did not specify shared memory size.
    opts="${opts} --shm-size=2gb"
fi

if [[ " ${opts} " != *" --restart="* && " ${opts}} " != *" -d "* ]]; then
    # User did not specify '--restart=' or '-d'
    opts="${opts} --rm"
fi

if [[ "$(which nvidia-smi 2>/dev/null)" != '' && "${gpu_devices}" != none ]]; then
    # opts="${opts} --runtime=nvidia"
    opts="${opts} -e NVIDIA_VISIBLE_DEVICES=${gpu_devices}"
    # or --gpus=all ?
fi

opts="${opts} -e HOST_NAME=$(uname) -e HOST_WHOAMI=$(whoami)"
if [[ "$(uname)" == Linux ]]; then
    # opts="${opts} -e HOST_IP=$(hostname -i)"
    opts="${opts} -e HOST_IP=$(ip route get 1 | awk '{gsub("^.*src ",""); print $1; exit}')"
fi

if [[ "${command}" == "notebook" ]]; then
    opts="${opts} --expose=${nb_port} -p ${nb_port}:${nb_port}"
    opts="${opts} -e JUPYTER_DATA_DIR=/home/docker-user/tmp/.jupyter/data"
    opts="${opts} -e JUPYTER_RUNTIME_DIR=/home/docker-user/tmp/.jupyter/runtime"
    command="jupyter notebook --port=${nb_port} --no-browser --ip=0.0.0.0 --NotebookApp.notebook_dir='${DOCKERHOMEDIR}' --NotebookApp.token=''"
fi


opts="${opts}
--user=docker-user
-e IMAGE_NAME=${imagename}
-e IMAGE_VERSION=${imageversion}
-e TZ=America/Los_Angeles
-e PROJ=${PROJ}
--init"


DATAVOLUME=docker-data-volume
MOUNTPOINT="${DOCKERHOMEDIR}/mnt"
VOLOPT="--mount source=${DATAVOLUME},target=${MOUNTPOINT}"

docker run ${opts} ${VOLOPT} ${IMAGENAME} ${command} ${args}

